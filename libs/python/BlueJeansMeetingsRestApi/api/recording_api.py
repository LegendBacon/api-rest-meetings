# coding: utf-8

"""
    BlueJeans Meetings REST API

     ## Video That Works Where You Do. <p>This site provides developers access to APIs from BlueJean's Meetings meeting service.  From here you can see and try actual API calls to manage User Accounts, Meetings, and Recordings, pull Analytical Data and Current State information.</p>    <nosdk> <hr> <div> <div class=\"key\">     <a href=\"./basics.html\" target=\"_\"><img class=\"keyimg\" src=\"./img/bjnmeeting.png\"/></a> </div> <div class=\"keybox\"> Basic instructions about What is a BlueJeans Meeting, and Getting Started Using API's, are <a href=\"./basics.html\" target=\"_blank\">available here <i class=\"glyphicon glyphicon-new-window\"></i></a>. </div> </div> <hr> <alert>2/21/2019</alert> Change response of Change layout and Endpoint API's to 204<br/> 12/03/2018 Add API for setting user profile photograph.<br/> 10/17/2018 Updated API field definitions for time variables to be 64-bit .<br/> 7/23/2018 Corrected errors in API definition file.<br/> 7/10/2018 Deprecated some Command Center API's.  Exposed API's that Summarize usage.<br/> 7/06/2018 Added API for changing ownership of recordings.<br/> 6/28/2018 Restored Create Enterprise Account, added Enterprise and User Profile Tag API's.<br/> 6/01/2018 Clarified Access Token requirements for meeting endpoint API's.<br/> 5/21/2018 Corrected return model for meeting history call.<br/> </nosdk> <hr>   # noqa: E501

    OpenAPI spec version: 1.0.4402212019
    Contact: glenn@bluejeans.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from BlueJeansMeetingsRestApi.api_client import ApiClient


class RecordingApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def create_share_recordings(self, user_id, meeting_guid, set_sharing, **kwargs):  # noqa: E501
        """Enable Recording Sharing  # noqa: E501

        This endpoint creates a sharing authorization record for the specified meeting recording.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_share_recordings(user_id, meeting_guid, set_sharing, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The ID of the user of interest. This value is an integer which can be retrieved for the current user via the Get User Account Details endpoint. (required)
        :param str meeting_guid: The globally unique identifier (GUID) of the meeting of interest. This value is a string which contains the numeric meeting id, followed by a colon, followed by a 128-bit integer number formatted as 5 alphanumeric segments separated by dashes. (required)
        :param SetSharing set_sharing: (required)
        :return: MeetingSharing
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_share_recordings_with_http_info(user_id, meeting_guid, set_sharing, **kwargs)  # noqa: E501
        else:
            (data) = self.create_share_recordings_with_http_info(user_id, meeting_guid, set_sharing, **kwargs)  # noqa: E501
            return data

    def create_share_recordings_with_http_info(self, user_id, meeting_guid, set_sharing, **kwargs):  # noqa: E501
        """Enable Recording Sharing  # noqa: E501

        This endpoint creates a sharing authorization record for the specified meeting recording.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_share_recordings_with_http_info(user_id, meeting_guid, set_sharing, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The ID of the user of interest. This value is an integer which can be retrieved for the current user via the Get User Account Details endpoint. (required)
        :param str meeting_guid: The globally unique identifier (GUID) of the meeting of interest. This value is a string which contains the numeric meeting id, followed by a colon, followed by a 128-bit integer number formatted as 5 alphanumeric segments separated by dashes. (required)
        :param SetSharing set_sharing: (required)
        :return: MeetingSharing
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'meeting_guid', 'set_sharing']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_share_recordings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `create_share_recordings`")  # noqa: E501
        # verify the required parameter 'meeting_guid' is set
        if ('meeting_guid' not in params or
                params['meeting_guid'] is None):
            raise ValueError("Missing the required parameter `meeting_guid` when calling `create_share_recordings`")  # noqa: E501
        # verify the required parameter 'set_sharing' is set
        if ('set_sharing' not in params or
                params['set_sharing'] is None):
            raise ValueError("Missing the required parameter `set_sharing` when calling `create_share_recordings`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501
        if 'meeting_guid' in params:
            path_params['meetingGuid'] = params['meeting_guid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'set_sharing' in params:
            body_params = params['set_sharing']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['access_token']  # noqa: E501

        return self.api_client.call_api(
            '/v1/user/{user_id}/meeting_history/{meetingGuid}/sharing/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MeetingSharing',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_all_recordings_by_meeting_guid(self, user_id, meeting_guid, **kwargs):  # noqa: E501
        """Delete All Recordings for a Specified Meeting GUID  # noqa: E501

        This endpoint stops recording for a meeting in progress.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_all_recordings_by_meeting_guid(user_id, meeting_guid, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The ID of the user of interest. This value is an integer which can be retrieved for the current user via the Get User Account Details endpoint. (required)
        :param str meeting_guid: The globally unique identifier (GUID) of the meeting of interest. This value is a string which contains the numeric meeting id, followed by a colon, followed by a 128-bit integer number formatted as 5 alphanumeric segments separated by dashes. Since a given numeric meeting ID can have multiple instantiations over time, the GUID helps identify the instance of interest. (required)
        :return: Meeting
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_all_recordings_by_meeting_guid_with_http_info(user_id, meeting_guid, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_all_recordings_by_meeting_guid_with_http_info(user_id, meeting_guid, **kwargs)  # noqa: E501
            return data

    def delete_all_recordings_by_meeting_guid_with_http_info(self, user_id, meeting_guid, **kwargs):  # noqa: E501
        """Delete All Recordings for a Specified Meeting GUID  # noqa: E501

        This endpoint stops recording for a meeting in progress.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_all_recordings_by_meeting_guid_with_http_info(user_id, meeting_guid, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The ID of the user of interest. This value is an integer which can be retrieved for the current user via the Get User Account Details endpoint. (required)
        :param str meeting_guid: The globally unique identifier (GUID) of the meeting of interest. This value is a string which contains the numeric meeting id, followed by a colon, followed by a 128-bit integer number formatted as 5 alphanumeric segments separated by dashes. Since a given numeric meeting ID can have multiple instantiations over time, the GUID helps identify the instance of interest. (required)
        :return: Meeting
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'meeting_guid']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_all_recordings_by_meeting_guid" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `delete_all_recordings_by_meeting_guid`")  # noqa: E501
        # verify the required parameter 'meeting_guid' is set
        if ('meeting_guid' not in params or
                params['meeting_guid'] is None):
            raise ValueError("Missing the required parameter `meeting_guid` when calling `delete_all_recordings_by_meeting_guid`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501
        if 'meeting_guid' in params:
            path_params['meeting_guid'] = params['meeting_guid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['access_token']  # noqa: E501

        return self.api_client.call_api(
            '/v1/user/{user_id}/meeting_history/{meeting_guid}/recordings/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Meeting',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_recording_chapter(self, user_id, meeting_id, recording_chapter_id, **kwargs):  # noqa: E501
        """Delete a Specified Recording Chapter  # noqa: E501

        This endpoint stops recording for a meeting in progress.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_recording_chapter(user_id, meeting_id, recording_chapter_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The ID of the user of interest. This value is an integer which can be retrieved for the current user via the Get User Account Details endpoint. (required)
        :param int meeting_id: The ID of the meeting you want to view. This is an integer value. You can find this ID by doing a list of meetings and referencing the \"id\" property. (required)
        :param int recording_chapter_id: The ID of the meeting you want to view. This is an integer value. You can find this ID by doing a list of meetings and referencing the \"id\" property. (required)
        :return: Meeting
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_recording_chapter_with_http_info(user_id, meeting_id, recording_chapter_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_recording_chapter_with_http_info(user_id, meeting_id, recording_chapter_id, **kwargs)  # noqa: E501
            return data

    def delete_recording_chapter_with_http_info(self, user_id, meeting_id, recording_chapter_id, **kwargs):  # noqa: E501
        """Delete a Specified Recording Chapter  # noqa: E501

        This endpoint stops recording for a meeting in progress.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_recording_chapter_with_http_info(user_id, meeting_id, recording_chapter_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The ID of the user of interest. This value is an integer which can be retrieved for the current user via the Get User Account Details endpoint. (required)
        :param int meeting_id: The ID of the meeting you want to view. This is an integer value. You can find this ID by doing a list of meetings and referencing the \"id\" property. (required)
        :param int recording_chapter_id: The ID of the meeting you want to view. This is an integer value. You can find this ID by doing a list of meetings and referencing the \"id\" property. (required)
        :return: Meeting
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'meeting_id', 'recording_chapter_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_recording_chapter" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `delete_recording_chapter`")  # noqa: E501
        # verify the required parameter 'meeting_id' is set
        if ('meeting_id' not in params or
                params['meeting_id'] is None):
            raise ValueError("Missing the required parameter `meeting_id` when calling `delete_recording_chapter`")  # noqa: E501
        # verify the required parameter 'recording_chapter_id' is set
        if ('recording_chapter_id' not in params or
                params['recording_chapter_id'] is None):
            raise ValueError("Missing the required parameter `recording_chapter_id` when calling `delete_recording_chapter`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501
        if 'meeting_id' in params:
            path_params['meeting_id'] = params['meeting_id']  # noqa: E501
        if 'recording_chapter_id' in params:
            path_params['recording_chapter_id'] = params['recording_chapter_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['access_token']  # noqa: E501

        return self.api_client.call_api(
            '/v1/user/{user_id}/meeting_history/{meeting_id}/recordings/{recording_chapter_id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Meeting',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_share_recordings(self, user_id, meeting_guid, **kwargs):  # noqa: E501
        """Delete Recording Sharing  # noqa: E501

        This endpoint deletes the sharing authorization associated with a meeting recording.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_share_recordings(user_id, meeting_guid, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The ID of the user of interest. This value is an integer which can be retrieved for the current user via the Get User Account Details endpoint. (required)
        :param str meeting_guid: The globally unique identifier (GUID) of the meeting of interest. This value is a string which contains the numeric meeting id, followed by a colon, followed by a 128-bit integer number formatted as 5 alphanumeric segments separated by dashes. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_share_recordings_with_http_info(user_id, meeting_guid, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_share_recordings_with_http_info(user_id, meeting_guid, **kwargs)  # noqa: E501
            return data

    def delete_share_recordings_with_http_info(self, user_id, meeting_guid, **kwargs):  # noqa: E501
        """Delete Recording Sharing  # noqa: E501

        This endpoint deletes the sharing authorization associated with a meeting recording.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_share_recordings_with_http_info(user_id, meeting_guid, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The ID of the user of interest. This value is an integer which can be retrieved for the current user via the Get User Account Details endpoint. (required)
        :param str meeting_guid: The globally unique identifier (GUID) of the meeting of interest. This value is a string which contains the numeric meeting id, followed by a colon, followed by a 128-bit integer number formatted as 5 alphanumeric segments separated by dashes. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'meeting_guid']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_share_recordings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `delete_share_recordings`")  # noqa: E501
        # verify the required parameter 'meeting_guid' is set
        if ('meeting_guid' not in params or
                params['meeting_guid'] is None):
            raise ValueError("Missing the required parameter `meeting_guid` when calling `delete_share_recordings`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501
        if 'meeting_guid' in params:
            path_params['meetingGuid'] = params['meeting_guid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['access_token']  # noqa: E501

        return self.api_client.call_api(
            '/v1/user/{user_id}/meeting_history/{meetingGuid}/sharing/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_meeting_recordings(self, user_id, meeting_id, **kwargs):  # noqa: E501
        """Get All Recordings for a Specified Meeting ID  # noqa: E501

        This endpoint lists the recordings for a meeting.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_meeting_recordings(user_id, meeting_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The ID of the user of interest. This value is an integer which can be retrieved for the current user via the Get User Account Details endpoint. (required)
        :param int meeting_id: The ID of the meeting you want to view. This is an integer value. You can find this ID by doing a list of meetings and referencing the \"id\" property. (required)
        :param str meeting_guid: The globally unique identifier (GUID) of the meeting of interest. This value is a string which contains the numeric meeting id, followed by a colon, followed by a 128-bit integer number formatted as 5 alphanumeric segments separated by dashes. Since a given numeric meeting ID can have multiple instantiations over time, the GUID helps identify the instance of interest.
        :return: RecordingHistoryList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_meeting_recordings_with_http_info(user_id, meeting_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_meeting_recordings_with_http_info(user_id, meeting_id, **kwargs)  # noqa: E501
            return data

    def get_meeting_recordings_with_http_info(self, user_id, meeting_id, **kwargs):  # noqa: E501
        """Get All Recordings for a Specified Meeting ID  # noqa: E501

        This endpoint lists the recordings for a meeting.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_meeting_recordings_with_http_info(user_id, meeting_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The ID of the user of interest. This value is an integer which can be retrieved for the current user via the Get User Account Details endpoint. (required)
        :param int meeting_id: The ID of the meeting you want to view. This is an integer value. You can find this ID by doing a list of meetings and referencing the \"id\" property. (required)
        :param str meeting_guid: The globally unique identifier (GUID) of the meeting of interest. This value is a string which contains the numeric meeting id, followed by a colon, followed by a 128-bit integer number formatted as 5 alphanumeric segments separated by dashes. Since a given numeric meeting ID can have multiple instantiations over time, the GUID helps identify the instance of interest.
        :return: RecordingHistoryList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'meeting_id', 'meeting_guid']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_meeting_recordings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `get_meeting_recordings`")  # noqa: E501
        # verify the required parameter 'meeting_id' is set
        if ('meeting_id' not in params or
                params['meeting_id'] is None):
            raise ValueError("Missing the required parameter `meeting_id` when calling `get_meeting_recordings`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501
        if 'meeting_id' in params:
            path_params['meeting_id'] = params['meeting_id']  # noqa: E501

        query_params = []
        if 'meeting_guid' in params:
            query_params.append(('meetingGuid', params['meeting_guid']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['access_token']  # noqa: E501

        return self.api_client.call_api(
            '/v1/user/{user_id}/meeting_history/{meeting_id}/recordings', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RecordingHistoryList',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_recording_content(self, user_id, content_id, is_downloadable, **kwargs):  # noqa: E501
        """Get Recording Download Link  # noqa: E501

        This endpoint retrieves properties about the recording chapter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_recording_content(user_id, content_id, is_downloadable, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The ID of the user of interest. This value is an integer which can be retrieved for the current user via the Get User Account Details endpoint. (required)
        :param int content_id: The recording properties fetched with other API endpoints will return a compositeContentId or a contentId. That value can be used for this argument. (required)
        :param bool is_downloadable: Set to true. (required)
        :return: Content
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_recording_content_with_http_info(user_id, content_id, is_downloadable, **kwargs)  # noqa: E501
        else:
            (data) = self.get_recording_content_with_http_info(user_id, content_id, is_downloadable, **kwargs)  # noqa: E501
            return data

    def get_recording_content_with_http_info(self, user_id, content_id, is_downloadable, **kwargs):  # noqa: E501
        """Get Recording Download Link  # noqa: E501

        This endpoint retrieves properties about the recording chapter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_recording_content_with_http_info(user_id, content_id, is_downloadable, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The ID of the user of interest. This value is an integer which can be retrieved for the current user via the Get User Account Details endpoint. (required)
        :param int content_id: The recording properties fetched with other API endpoints will return a compositeContentId or a contentId. That value can be used for this argument. (required)
        :param bool is_downloadable: Set to true. (required)
        :return: Content
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'content_id', 'is_downloadable']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_recording_content" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `get_recording_content`")  # noqa: E501
        # verify the required parameter 'content_id' is set
        if ('content_id' not in params or
                params['content_id'] is None):
            raise ValueError("Missing the required parameter `content_id` when calling `get_recording_content`")  # noqa: E501
        # verify the required parameter 'is_downloadable' is set
        if ('is_downloadable' not in params or
                params['is_downloadable'] is None):
            raise ValueError("Missing the required parameter `is_downloadable` when calling `get_recording_content`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501
        if 'content_id' in params:
            path_params['content_id'] = params['content_id']  # noqa: E501

        query_params = []
        if 'is_downloadable' in params:
            query_params.append(('isDownloadable', params['is_downloadable']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['access_token']  # noqa: E501

        return self.api_client.call_api(
            '/v1/user/{user_id}/cms/{content_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Content',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_share_recordings(self, user_id, meeting_guid, **kwargs):  # noqa: E501
        """List Recording Sharing  # noqa: E501

        This endpoint retrieves a the sharing authorization information for a meeting's recording. If no sharing has been authorized for the meeting, this API returns a 404 error.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_share_recordings(user_id, meeting_guid, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The ID of the user of interest. This value is an integer which can be retrieved for the current user via the Get User Account Details endpoint. (required)
        :param str meeting_guid: The globally unique identifier (GUID) of the meeting of interest. This value is a string which contains the numeric meeting id, followed by a colon, followed by a 128-bit integer number formatted as 5 alphanumeric segments separated by dashes. (required)
        :return: MeetingSharing
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_share_recordings_with_http_info(user_id, meeting_guid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_share_recordings_with_http_info(user_id, meeting_guid, **kwargs)  # noqa: E501
            return data

    def get_share_recordings_with_http_info(self, user_id, meeting_guid, **kwargs):  # noqa: E501
        """List Recording Sharing  # noqa: E501

        This endpoint retrieves a the sharing authorization information for a meeting's recording. If no sharing has been authorized for the meeting, this API returns a 404 error.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_share_recordings_with_http_info(user_id, meeting_guid, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The ID of the user of interest. This value is an integer which can be retrieved for the current user via the Get User Account Details endpoint. (required)
        :param str meeting_guid: The globally unique identifier (GUID) of the meeting of interest. This value is a string which contains the numeric meeting id, followed by a colon, followed by a 128-bit integer number formatted as 5 alphanumeric segments separated by dashes. (required)
        :return: MeetingSharing
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'meeting_guid']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_share_recordings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `get_share_recordings`")  # noqa: E501
        # verify the required parameter 'meeting_guid' is set
        if ('meeting_guid' not in params or
                params['meeting_guid'] is None):
            raise ValueError("Missing the required parameter `meeting_guid` when calling `get_share_recordings`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501
        if 'meeting_guid' in params:
            path_params['meetingGuid'] = params['meeting_guid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['access_token']  # noqa: E501

        return self.api_client.call_api(
            '/v1/user/{user_id}/meeting_history/{meetingGuid}/sharing/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MeetingSharing',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def modify_share_recordings(self, user_id, meeting_guid, sharing_id, modify_sharing, **kwargs):  # noqa: E501
        """Modify Recording Sharing  # noqa: E501

        This endpoint modifieds the sharing authorization attributes for a meeting recording.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.modify_share_recordings(user_id, meeting_guid, sharing_id, modify_sharing, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The ID of the user of interest. This value is an integer which can be retrieved for the current user via the Get User Account Details endpoint. (required)
        :param str meeting_guid: The globally unique identifier (GUID) of the meeting of interest. This value is a string which contains the numeric meeting id, followed by a colon, followed by a 128-bit integer number formatted as 5 alphanumeric segments separated by dashes. (required)
        :param str sharing_id: The identifier of the sharing authorization record.  This value can be obtained from the \"Id\" in the response to the API GET /v1/user/{user_id}/meeting_history/{meetingGuid}/sharing (required)
        :param ModifySharing modify_sharing: (required)
        :return: MeetingSharing
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.modify_share_recordings_with_http_info(user_id, meeting_guid, sharing_id, modify_sharing, **kwargs)  # noqa: E501
        else:
            (data) = self.modify_share_recordings_with_http_info(user_id, meeting_guid, sharing_id, modify_sharing, **kwargs)  # noqa: E501
            return data

    def modify_share_recordings_with_http_info(self, user_id, meeting_guid, sharing_id, modify_sharing, **kwargs):  # noqa: E501
        """Modify Recording Sharing  # noqa: E501

        This endpoint modifieds the sharing authorization attributes for a meeting recording.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.modify_share_recordings_with_http_info(user_id, meeting_guid, sharing_id, modify_sharing, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The ID of the user of interest. This value is an integer which can be retrieved for the current user via the Get User Account Details endpoint. (required)
        :param str meeting_guid: The globally unique identifier (GUID) of the meeting of interest. This value is a string which contains the numeric meeting id, followed by a colon, followed by a 128-bit integer number formatted as 5 alphanumeric segments separated by dashes. (required)
        :param str sharing_id: The identifier of the sharing authorization record.  This value can be obtained from the \"Id\" in the response to the API GET /v1/user/{user_id}/meeting_history/{meetingGuid}/sharing (required)
        :param ModifySharing modify_sharing: (required)
        :return: MeetingSharing
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'meeting_guid', 'sharing_id', 'modify_sharing']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method modify_share_recordings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `modify_share_recordings`")  # noqa: E501
        # verify the required parameter 'meeting_guid' is set
        if ('meeting_guid' not in params or
                params['meeting_guid'] is None):
            raise ValueError("Missing the required parameter `meeting_guid` when calling `modify_share_recordings`")  # noqa: E501
        # verify the required parameter 'sharing_id' is set
        if ('sharing_id' not in params or
                params['sharing_id'] is None):
            raise ValueError("Missing the required parameter `sharing_id` when calling `modify_share_recordings`")  # noqa: E501
        # verify the required parameter 'modify_sharing' is set
        if ('modify_sharing' not in params or
                params['modify_sharing'] is None):
            raise ValueError("Missing the required parameter `modify_sharing` when calling `modify_share_recordings`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501
        if 'meeting_guid' in params:
            path_params['meetingGuid'] = params['meeting_guid']  # noqa: E501
        if 'sharing_id' in params:
            path_params['sharingId'] = params['sharing_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'modify_sharing' in params:
            body_params = params['modify_sharing']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['access_token']  # noqa: E501

        return self.api_client.call_api(
            '/v1/user/{user_id}/meeting_history/{meetingGuid}/sharing/{sharingId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MeetingSharing',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def move_recording_owner(self, user_id, original_owner, new_owner, **kwargs):  # noqa: E501
        """Move Recording Ownership  # noqa: E501

        This endpoint changes the ownership for all recordings from the original owner account and moves them to the new owner account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.move_recording_owner(user_id, original_owner, new_owner, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The ID of the user requesting the move.  This user must have Enterprise Administrator privileges.  This value is an integer which can be retrieved for the current user via the Get User Account Details endpoint. (required)
        :param int original_owner: The ID of the recording's current owner. (required)
        :param int new_owner: The ID of the intended owner for the recording. (required)
        :return: RecordingMovedComp
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.move_recording_owner_with_http_info(user_id, original_owner, new_owner, **kwargs)  # noqa: E501
        else:
            (data) = self.move_recording_owner_with_http_info(user_id, original_owner, new_owner, **kwargs)  # noqa: E501
            return data

    def move_recording_owner_with_http_info(self, user_id, original_owner, new_owner, **kwargs):  # noqa: E501
        """Move Recording Ownership  # noqa: E501

        This endpoint changes the ownership for all recordings from the original owner account and moves them to the new owner account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.move_recording_owner_with_http_info(user_id, original_owner, new_owner, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The ID of the user requesting the move.  This user must have Enterprise Administrator privileges.  This value is an integer which can be retrieved for the current user via the Get User Account Details endpoint. (required)
        :param int original_owner: The ID of the recording's current owner. (required)
        :param int new_owner: The ID of the intended owner for the recording. (required)
        :return: RecordingMovedComp
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'original_owner', 'new_owner']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method move_recording_owner" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `move_recording_owner`")  # noqa: E501
        # verify the required parameter 'original_owner' is set
        if ('original_owner' not in params or
                params['original_owner'] is None):
            raise ValueError("Missing the required parameter `original_owner` when calling `move_recording_owner`")  # noqa: E501
        # verify the required parameter 'new_owner' is set
        if ('new_owner' not in params or
                params['new_owner'] is None):
            raise ValueError("Missing the required parameter `new_owner` when calling `move_recording_owner`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501
        if 'original_owner' in params:
            path_params['originalOwner'] = params['original_owner']  # noqa: E501
        if 'new_owner' in params:
            path_params['newOwner'] = params['new_owner']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['access_token']  # noqa: E501

        return self.api_client.call_api(
            '/v1/user/{user_id}/meeting_history/move_recordings/from_user/{originalOwner}/to_user/{newOwner}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RecordingMovedComp',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def start_recording(self, user_id, meeting_id, action, **kwargs):  # noqa: E501
        """Start Recording  # noqa: E501

        This endpoint starts recording for a meeting in progress. Note that this is a POST operation. Stop is a PUT operation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.start_recording(user_id, meeting_id, action, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The ID of the user of interest. This value is an integer which can be retrieved for the current user via the Get User Account Details endpoint. (required)
        :param int meeting_id: The ID of the meeting you want to view. This is an integer value. You can find this ID by doing a list of meetings and referencing the \"id\" property. (required)
        :param str action: Always set to \"start\" in order to start recording. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.start_recording_with_http_info(user_id, meeting_id, action, **kwargs)  # noqa: E501
        else:
            (data) = self.start_recording_with_http_info(user_id, meeting_id, action, **kwargs)  # noqa: E501
            return data

    def start_recording_with_http_info(self, user_id, meeting_id, action, **kwargs):  # noqa: E501
        """Start Recording  # noqa: E501

        This endpoint starts recording for a meeting in progress. Note that this is a POST operation. Stop is a PUT operation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.start_recording_with_http_info(user_id, meeting_id, action, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The ID of the user of interest. This value is an integer which can be retrieved for the current user via the Get User Account Details endpoint. (required)
        :param int meeting_id: The ID of the meeting you want to view. This is an integer value. You can find this ID by doing a list of meetings and referencing the \"id\" property. (required)
        :param str action: Always set to \"start\" in order to start recording. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'meeting_id', 'action']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method start_recording" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `start_recording`")  # noqa: E501
        # verify the required parameter 'meeting_id' is set
        if ('meeting_id' not in params or
                params['meeting_id'] is None):
            raise ValueError("Missing the required parameter `meeting_id` when calling `start_recording`")  # noqa: E501
        # verify the required parameter 'action' is set
        if ('action' not in params or
                params['action'] is None):
            raise ValueError("Missing the required parameter `action` when calling `start_recording`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501
        if 'meeting_id' in params:
            path_params['meeting_id'] = params['meeting_id']  # noqa: E501

        query_params = []
        if 'action' in params:
            query_params.append(('action', params['action']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['access_token']  # noqa: E501

        return self.api_client.call_api(
            '/v1/user/{user_id}/live_meetings/{meeting_id}/recordings', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def stop_recording(self, user_id, meeting_id, action, **kwargs):  # noqa: E501
        """Stop Recording  # noqa: E501

        This endpoint stops recording for a meeting in progress. Note that this is a PUT operation. Start is a POST operation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.stop_recording(user_id, meeting_id, action, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The ID of the user of interest. This value is an integer which can be retrieved for the current user via the Get User Account Details endpoint. (required)
        :param int meeting_id: The ID of the meeting you want to view. This is an integer value. You can find this ID by doing a list of meetings and referencing the \"id\" property. (required)
        :param str action: Always set to \"stop\" in order to stop recording. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.stop_recording_with_http_info(user_id, meeting_id, action, **kwargs)  # noqa: E501
        else:
            (data) = self.stop_recording_with_http_info(user_id, meeting_id, action, **kwargs)  # noqa: E501
            return data

    def stop_recording_with_http_info(self, user_id, meeting_id, action, **kwargs):  # noqa: E501
        """Stop Recording  # noqa: E501

        This endpoint stops recording for a meeting in progress. Note that this is a PUT operation. Start is a POST operation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.stop_recording_with_http_info(user_id, meeting_id, action, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The ID of the user of interest. This value is an integer which can be retrieved for the current user via the Get User Account Details endpoint. (required)
        :param int meeting_id: The ID of the meeting you want to view. This is an integer value. You can find this ID by doing a list of meetings and referencing the \"id\" property. (required)
        :param str action: Always set to \"stop\" in order to stop recording. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'meeting_id', 'action']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stop_recording" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `stop_recording`")  # noqa: E501
        # verify the required parameter 'meeting_id' is set
        if ('meeting_id' not in params or
                params['meeting_id'] is None):
            raise ValueError("Missing the required parameter `meeting_id` when calling `stop_recording`")  # noqa: E501
        # verify the required parameter 'action' is set
        if ('action' not in params or
                params['action'] is None):
            raise ValueError("Missing the required parameter `action` when calling `stop_recording`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501
        if 'meeting_id' in params:
            path_params['meeting_id'] = params['meeting_id']  # noqa: E501

        query_params = []
        if 'action' in params:
            query_params.append(('action', params['action']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['access_token']  # noqa: E501

        return self.api_client.call_api(
            '/v1/user/{user_id}/live_meetings/{meeting_id}/recordings', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
